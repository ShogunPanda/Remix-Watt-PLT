// This client was generated by Platformatic from an OpenAPI specification.

// The base URL for the API. This can be overridden by calling `setBaseUrl`.
let baseUrl = ''
// The default headers to send within each request. This can be overridden by calling `setDefaultHeaders`.
let defaultHeaders = {}

function sanitizeUrl(url) {
  if (url.endsWith('/')) { return url.slice(0, -1) } else { return url }
}
/**  @type {import('./remix-client-types.d.ts').RemixClient['setBaseUrl']} */
export const setBaseUrl = (newUrl) => { baseUrl = sanitizeUrl(newUrl) }

/**  @type {import('./remix-client-types.d.ts').RemixClient['setDefaultHeaders']} */
export const setDefaultHeaders = (headers) => { defaultHeaders = headers }

function headersToJSON(headers) {
  const output = {}
  headers.forEach((value, key) => {
    output[key] = value
  })
  return output
}

async function _postgresDbGetProducts (url, request) {
  const queryParameters = ['limit', 'offset', 'totalCount', 'fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.ilike', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.imageUrl.eq', 'where.imageUrl.neq', 'where.imageUrl.gt', 'where.imageUrl.gte', 'where.imageUrl.lt', 'where.imageUrl.lte', 'where.imageUrl.like', 'where.imageUrl.ilike', 'where.imageUrl.in', 'where.imageUrl.nin', 'where.imageUrl.contains', 'where.imageUrl.contained', 'where.imageUrl.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.ilike', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.price.eq', 'where.price.neq', 'where.price.gt', 'where.price.gte', 'where.price.lt', 'where.price.lte', 'where.price.like', 'where.price.ilike', 'where.price.in', 'where.price.nin', 'where.price.contains', 'where.price.contained', 'where.price.overlaps', 'where.updatedAt.eq', 'where.updatedAt.neq', 'where.updatedAt.gt', 'where.updatedAt.gte', 'where.updatedAt.lt', 'where.updatedAt.lte', 'where.updatedAt.like', 'where.updatedAt.ilike', 'where.updatedAt.in', 'where.updatedAt.nin', 'where.updatedAt.contains', 'where.updatedAt.contained', 'where.updatedAt.overlaps', 'where.or', 'orderby.createdAt', 'orderby.description', 'orderby.id', 'orderby.imageUrl', 'orderby.name', 'orderby.price', 'orderby.updatedAt']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/postgres-db/products/?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./remix-client-types.d.ts').RemixClient['postgresDbGetProducts']} */
export const postgresDbGetProducts = async (request) => {
  return await _postgresDbGetProducts(baseUrl, request)
}
async function _postgresDbCreateProduct (url, request) {
  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/postgres-db/products/`, {
    method: 'POST',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./remix-client-types.d.ts').RemixClient['postgresDbCreateProduct']} */
export const postgresDbCreateProduct = async (request) => {
  return await _postgresDbCreateProduct(baseUrl, request)
}
async function _postgresDbUpdateProducts (url, request) {
  const queryParameters = ['fields', 'where.createdAt.eq', 'where.createdAt.neq', 'where.createdAt.gt', 'where.createdAt.gte', 'where.createdAt.lt', 'where.createdAt.lte', 'where.createdAt.like', 'where.createdAt.ilike', 'where.createdAt.in', 'where.createdAt.nin', 'where.createdAt.contains', 'where.createdAt.contained', 'where.createdAt.overlaps', 'where.description.eq', 'where.description.neq', 'where.description.gt', 'where.description.gte', 'where.description.lt', 'where.description.lte', 'where.description.like', 'where.description.ilike', 'where.description.in', 'where.description.nin', 'where.description.contains', 'where.description.contained', 'where.description.overlaps', 'where.id.eq', 'where.id.neq', 'where.id.gt', 'where.id.gte', 'where.id.lt', 'where.id.lte', 'where.id.like', 'where.id.ilike', 'where.id.in', 'where.id.nin', 'where.id.contains', 'where.id.contained', 'where.id.overlaps', 'where.imageUrl.eq', 'where.imageUrl.neq', 'where.imageUrl.gt', 'where.imageUrl.gte', 'where.imageUrl.lt', 'where.imageUrl.lte', 'where.imageUrl.like', 'where.imageUrl.ilike', 'where.imageUrl.in', 'where.imageUrl.nin', 'where.imageUrl.contains', 'where.imageUrl.contained', 'where.imageUrl.overlaps', 'where.name.eq', 'where.name.neq', 'where.name.gt', 'where.name.gte', 'where.name.lt', 'where.name.lte', 'where.name.like', 'where.name.ilike', 'where.name.in', 'where.name.nin', 'where.name.contains', 'where.name.contained', 'where.name.overlaps', 'where.price.eq', 'where.price.neq', 'where.price.gt', 'where.price.gte', 'where.price.lt', 'where.price.lte', 'where.price.like', 'where.price.ilike', 'where.price.in', 'where.price.nin', 'where.price.contains', 'where.price.contained', 'where.price.overlaps', 'where.updatedAt.eq', 'where.updatedAt.neq', 'where.updatedAt.gt', 'where.updatedAt.gte', 'where.updatedAt.lt', 'where.updatedAt.lte', 'where.updatedAt.like', 'where.updatedAt.ilike', 'where.updatedAt.in', 'where.updatedAt.nin', 'where.updatedAt.contains', 'where.updatedAt.contained', 'where.updatedAt.overlaps', 'where.or']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/postgres-db/products/?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./remix-client-types.d.ts').RemixClient['postgresDbUpdateProducts']} */
export const postgresDbUpdateProducts = async (request) => {
  return await _postgresDbUpdateProducts(baseUrl, request)
}
async function _postgresDbGetProductById (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/postgres-db/products/${request['id']}?${searchParams.toString()}`, {
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./remix-client-types.d.ts').RemixClient['postgresDbGetProductById']} */
export const postgresDbGetProductById = async (request) => {
  return await _postgresDbGetProductById(baseUrl, request)
}
async function _postgresDbUpdateProduct (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/postgres-db/products/${request['id']}?${searchParams.toString()}`, {
    method: 'PUT',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./remix-client-types.d.ts').RemixClient['postgresDbUpdateProduct']} */
export const postgresDbUpdateProduct = async (request) => {
  return await _postgresDbUpdateProduct(baseUrl, request)
}
async function _postgresDbDeleteProducts (url, request) {
  const queryParameters = ['fields']
  const searchParams = new URLSearchParams()
  queryParameters.forEach((qp) => {
    if (request[qp]) {
      if (Array.isArray(request[qp])) {
        request[qp].forEach((p) => {
          searchParams.append(qp, p)
        })
      } else {
        searchParams.append(qp, request[qp]?.toString() || '')
      }
    }
    delete request[qp]
  })

  const headers = {
    ...defaultHeaders,
    'Content-type': 'application/json; charset=utf-8'
  }

  const response = await fetch(`${url}/postgres-db/products/${request['id']}?${searchParams.toString()}`, {
    method: 'DELETE',
    body: JSON.stringify(request),
    headers
  })

  if (!response.ok) {
    throw new Error(await response.text())
  }

  return await response.json()
}

/**  @type {import('./remix-client-types.d.ts').RemixClient['postgresDbDeleteProducts']} */
export const postgresDbDeleteProducts = async (request) => {
  return await _postgresDbDeleteProducts(baseUrl, request)
}
async function _getPostgresDbExample (url, request) {
  const headers = {
    ...defaultHeaders
  }

  const response = await fetch(`${url}/postgres-db/example`, {
    headers
  })

  const textResponses = [200]
  if (textResponses.includes(response.status)) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.text()
    }
  }
  if (response.headers.get('content-type')?.startsWith('application/json')) {
    return {
      statusCode: response.status,
      headers: headersToJSON(response.headers),
      body: await response.json()
    }
  }
  return {
    statusCode: response.status,
    headers: headersToJSON(response.headers),
    body: await response.text()
  }
}

/**  @type {import('./remix-client-types.d.ts').RemixClient['getPostgresDbExample']} */
export const getPostgresDbExample = async (request) => {
  return await _getPostgresDbExample(baseUrl, request)
}
export default function build (url, options) {
  url = sanitizeUrl(url)
  if (options?.headers) {
    defaultHeaders = options.headers
  }
  return {
    postgresDbGetProducts: _postgresDbGetProducts.bind(url, ...arguments),
    postgresDbCreateProduct: _postgresDbCreateProduct.bind(url, ...arguments),
    postgresDbUpdateProducts: _postgresDbUpdateProducts.bind(url, ...arguments),
    postgresDbGetProductById: _postgresDbGetProductById.bind(url, ...arguments),
    postgresDbUpdateProduct: _postgresDbUpdateProduct.bind(url, ...arguments),
    postgresDbDeleteProducts: _postgresDbDeleteProducts.bind(url, ...arguments),
    getPostgresDbExample: _getPostgresDbExample.bind(url, ...arguments)
  }
}